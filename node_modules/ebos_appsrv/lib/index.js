require('newrelic');

var path = require('path');
var Hapi = require('hapi');
var Boom = require('boom');
var Wreck = require('wreck');
var ejs = require('ejs');
var APIS = require('ebos_apis');
var view_path = "./views";

var Filters = require('../../../public/js/filters');
var	Globalize = require('../../../public/js/ebos_globalize');

var OS = require('os');

// Load this app's package json -- this is whomsoever required it
var	ThisApp = require('../../../package.json');

var internals = {};

var fla_function = require('./fla_function');

// Setup some common properties:  Let's expose these to the app
exports.APIS = APIS;
exports.Wreck = Wreck;
exports.Boom = Boom;
exports.Globalize = Globalize;
// internals.APIS.API_list(APIS);

exports.app_name = internals.app_name = ThisApp.name;
exports.app_version = internals.app_version = ThisApp.version;
exports.app_description = internals.app_description = ThisApp.description;
exports.remote_host = internals.remote_host = '';
exports.this_host = internals.this_host = 'http://localhost:3000';		// Default

exports.cloud_host = process.env.CLOUD_HOST || 'http://staging.mcdebos.com';
exports.cash_host = process.env.CASH_HOST || exports.cloud_host;
exports.inv_host = process.env.INV_HOST || exports.cloud_host;
exports.apis_host = process.env.APIS_HOST || exports.cloud_host;

// These will typically be available locally
exports.dashboard_host = process.env.DASHBOARD_HOST || (process.env.IN_STORE ? exports.this_host : exports.cloud_host);
exports.local_cash_host = process.env.LOCAL_CASH_HOST || (process.env.IN_STORE ? exports.this_host : null);
exports.local_api_host = (process.env.LOCAL_API_HOST || 'http://localhost:8123') + '/npsharp/';

exports.cloud_api_host = exports.cloud_host + '/api/';

ejs.filters.titleCase = Filters.titleCase;
ejs.filters.commaNum = Filters.commaNum;
ejs.filters.prettyCol = Filters.prettyCol;
ejs.filters.parseFloat = Filters.parseFloat;
ejs.filters.realQuotes = Filters.realQuotes;
ejs.filters.htmlCharQuotes = Filters.htmlCharQuotes;
ejs.filters.jsonStringify = Filters.jsonStringify;
ejs.filters.jsonParse = Filters.jsonParse;
ejs.filters.prettyDate = Filters.prettyDate;
ejs.filters.prettyISODate = Filters.prettyISODate;
ejs.filters.prettyShortDate = Filters.prettyShortDate;

ejs.filters.translate = function(msg) {
	return Globalize.ebos_translate(msg);
};
ejs.filters.locale = function(msg) {
	return Globalize.locale().locale;
};

exports.fla = function fla(field,value,options) {
	var access = getAccessLevel(field);
	if (access === "no_access") {
		return "";
	} else {
		return fla_function[field.type][access](field,value,options);
	}
}

var myLevel = 7;

function getAccessLevel(field) {
	if (typeof field.full_access !== "undefined" && myLevel >= field.full_access) {
		return "full_access";
	} else if (typeof field.read_only !== "undefined" && myLevel >= field.read_only) {
		return "read_only";
	} else {
		return "no_access";
	}
}

exports.initialize = function initialize(host, port, logger) {

	var options = {
		host: host,
		port: port,
		routes: {
			cors: {
				origin: ['*'],	// Allow from anywhere for now
				additionalHeaders: [	'X-User-Language',
										'X-Local-Host'
									],
				additionalExposedHeaders: [	'X-eBos-AppName',
											'X-eBos-AppVersion',
											'X-eBos-Sidebar',
										],
			}
		}
	};

	if(process.env.IN_STORE){
		options.address = OS.hostname();
	}

	var loggingOptions = {};

	exports.server = new Hapi.Server();
	exports.server.connection(options);
	exports.server.views({
		engines: {ejs: ejs},
		path: view_path,
		isCached: false
	});

	exports.server.decorate('reply', 'fla_view', function (template, context, options) {
		var field_file = path.join('../../..', view_path, template + '.fla.js')
		context.fields = require(field_file);
    	return this.view(template, context, options);
	});

	if(logger) {
		if (logger.location == 'remote') {
			loggingOptions = {
				logRequestHeaders: true,
				reporters: [{
					reporter: require('good-http-local'),
					args: [{ response: '*', log: '*', error: '*' }, logger.url, {
						threshold: 0,
						wreck: {
							headers: { 'x-prod-key' : exports.app_name,'x-env-key' : logger.env }
						}
					}]
				}]
			};
		} else if (logger.location == 'local') {
			loggingOptions = {
				reporters: [{
					reporter: require('good-console'),
					args: [{ response: '*', log: '*', error: '*' }]
				}]
			};
		}

		// Start the bugger
		if (loggingOptions) {
			exports.server.register({
				register: require('good'),
				options: loggingOptions
			}, function (err) {
			   if (err) {
				  console.log(err);
				  return;
			   }
			});
		}
	}

	exports.server.ext('onPreHandler', function (request, reply) {

		Globalize.locale(locale(request.headers));
		AppServer.remote_host = request.raw.req.connection.remoteAddress;

		reply.continue();

	});

	exports.server.ext('onPreResponse', function (request, reply) {
		if(request.response.headers) {
			request.response.headers['X-eBos-AppName'] = AppServer.app_name;
			request.response.headers['X-eBos-AppVersion'] = AppServer.app_version;
		}
		reply.continue();
	});

	// Set up routes that everyone needs
	exports.server.route([
		exports.APIS.LB0000.route,
		exports.APIS.DEV0000.route,
		exports.APIS.DEV0001.route
	]);

	exports.server.start(function() {
		// Setup a single socket.io object for use by the frontend
		exports.IO = require('socket.io')(exports.server.listener);
		exports.IO.set('transports', ["websocket", "polling"]);
		exports.IO.on("connection", function(socket){
			socket.on("disconnect", function () {
			});
		});

		// Server is started so let's setup links to other hosts
		if(process.env.IN_STORE) {
			// If we're IN_STORE then the dashboard and local_cash_host are local as well
			exports.this_host = 'http://' + exports.server.info.address + ':' + exports.server.info.port;
			exports.this_uri = exports.this_host;
			exports.dashboard_host = process.env.DASHBOARD_HOST || exports.this_uri;
			exports.local_cash_host = process.env.LOCAL_CASH_HOST || exports.this_uri;
		} else {
			exports.this_uri = exports.cloud_host;
			exports.dashboard_host = process.env.DASHBOARD_HOST || exports.this_uri;
			exports.local_cash_host = process.env.LOCAL_CASH_HOST || null;
		}

		if (process.env.DEV) {
			// If DEV is set, try to set the host name for that app to exports.this_host
			exports.dashboard_host = exports.this_host;
			var app_host = exports.app_name + '_host';
			if(exports[app_host]) {
				exports[app_host] = exports.this_host;
			}
		}

		console.log('Server running at: ' + exports.this_host);
		console.log('local_api=' + exports.local_api_host);
		console.log('cloud_api=' + exports.cloud_api_host);
		console.log('cloud=' + exports.cloud_host);
		console.log('dash=' + exports.dashboard_host);
		console.log('cash=' + exports.cash_host);
		console.log('inv=' + exports.inv_host);
		console.log('api=' + exports.apis_host);
		console.log('local_cash=' + exports.local_cash_host);
	});
};



///////////////////////////////////////////////////////
//
//	Bunch of private routines
//
//
//
///////////////////////////////////////////////////////
var cookieParse = function(str) {
    var obj = {}
    var pairs = str.split(/; */);

    pairs.forEach(function(pair) {
        var eq_idx = pair.indexOf('=')

        // skip things that don't look like key=value
        if (eq_idx < 0) {
            return;
        }

        var key = pair.substr(0, eq_idx).trim()
        var val = pair.substr(++eq_idx, pair.length).trim();

        // quoted values
        if ('"' == val[0]) {
            val = val.slice(1, -1);
        }

        // only assign once
        if (undefined == obj[key]) {
            obj[key] = val;
        }
    });

    return obj;
};

function parseLocale(str) {
	var country, language, match, normalized;
	if (!(match = str != null ? str.match(/[a-z]+/gi) : void 0)) {
		return;
	}
	language = match[0], country = match[1];
	this.code = str;
	this.language = language.toLowerCase();
	if (country) {
		this.country = country.toUpperCase();
	}
	normalized = [this.language];
	if (this.country) {
		normalized.push(this.country);
	}
	this.normalized = normalized.join("_");
}


function parseAccLang(str) {
	var accLangs = [];

	var item, locale, q, _ref, _ref1;
	if (!str) {
		return accLangs;
	}
	_ref = (String(str)).split(",");
	for (var i = 0; i < _ref.length; i++) {
		item = _ref[i];
		_ref1 = item.split(";")
		locale = _ref1[0]
		q = _ref1[1];
		locale = new parseLocale(locale.trim());
		locale.score = q ? +q.slice(2) || 0 : 1;
		accLangs.push(locale);
	}
	accLangs.sort(function(a, b) {
		return b.score - a.score;
	});

	return accLangs;
}

function bestLang(str) {
	var supportedLangs = ['en', 'es', 'fr'];
	var accLangs = parseAccLang(str);
	for (var i=0; i < accLangs.length; i++) {
		for (var j = 0; j < supportedLangs.length; j++) {
			if (accLangs[i].language === supportedLangs[j]) {
				return accLangs[i].language;
			}
		}
	}
	return "en";
}

function locale(headers) {
	if (typeof headers.cookie !== "undefined") {
		var cookies = cookieParse(headers.cookie);
	}
	if (typeof cookies !== "undefined" && typeof cookies._locale !== "undefined") {
		return cookies._locale;
	} else if (headers['x-user-language'] ) {
		return bestLang(headers['x-user-language']);
	} else {
		return bestLang(headers['accept-language']);
	}
}
